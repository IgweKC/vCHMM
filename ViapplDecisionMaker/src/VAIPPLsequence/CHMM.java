package VAIPPLsequence;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import math.Math;

/**
 * First-order Coupled Hidden Markov Model. A Coupled hidden Markov model (CHMM) is a statistical
 * Markov model in which the system being modeled is assumed to be a Markov
 * process with two sequences of unobserved (hidden) interacting states.
 *
 * An HMM can be considered as the
 * simplest dynamic Bayesian network. <p> In a regular Markov model, the state
 * is directly visible to the observer, and therefore the state transition
 * probabilities are the only parameters. In a hidden Markov model, the state is
 * not directly visible, but output, dependent on the state, is visible. Each
 * state has a probability distribution over the possible output tokens.
 * Therefore the sequence of tokens generated by an HMM gives some information
 * about the sequence of states.
 *
 * @author KC Igwe
 */
public class CHMM<O> implements vCoupledSequenceLabeler<O> {
    /**
     * The number of states. Array element 0
     * is the number of states in the first chain.
     */
    int[] numStatesPerChain;
    /**
     * The total number of states.
     */
    private int numStates;
    /**
     * The number of emission symbols. In this version of CHMM,
     * only the first chain emits some observations
     */
    private int numSymbols;
     /**
     * Initial state probabilities.
     */
    private double[] pi;
    /**
     * State transition probabilities.
     */
    private double[][] a;
    /**
     * Symbol emission probabilities.
     */
    private double[][] b;
    /**
     * coupling coefficients.
     */
    private double[][] theta;
    /**
     * The mapping from emission symbols to indices.
     */
    private Map<O, Integer> symbols;

    /**
     * Constructor.
     *
     * @param  numStatesPerChain the number of states per chain.
     * @param numSymbols the number of emission symbols in the first chain.
     */
    private CHMM(int[] numStatesPerChain, int numSymbols) {
        int numChains = numStatesPerChain.length;

        if(numChains < 2){
            throw new IllegalArgumentException("Invalid number of chains: " + numChains);
        }

        for(int i = 0; i < numChains; i++){
            if (numStatesPerChain[i] <= 0) {
                throw new IllegalArgumentException("Invalid number of states: " + numStatesPerChain[i]+
                        " in chain "+ i+1);
            }
        }


        if (numSymbols <= 0) {
            throw new IllegalArgumentException("Invalid number of emission symbols: " + numSymbols);
        }

        this.numStatesPerChain = new int[numChains];
        int aDim = Math.sum(numStatesPerChain);

        for(int i = 0; i < numChains; i++){
            this.numStatesPerChain[i] = numStatesPerChain[i];
        }
        this.numStates = aDim;
        this.numSymbols = numSymbols;
        pi = new double[aDim];
        a = new double[aDim][aDim];
        theta = new double[numChains][numChains];
        b = new double[numStatesPerChain[0]][numSymbols];
    }
    
    /**
     * Constructor.
     *
     * @param numStatesPerChain the number of states in each chain
     * @param pi the initial state probabilities.
     * @param a the state transition probabilities, of which a^[i][j] is P(s^_j |
     * s^_i); where 1 <= ^ <= C, and C is the number of chains
     * @param b the symbol emission probabilities, of which b^[i][j] is P(o_j |
     * s^_i). where ^ = 1 indicting the first chain
     */
    public CHMM(int[] numStatesPerChain, double[] pi, double[][] a, double[][] b, double[][] theta) {
        this(numStatesPerChain, pi, a, b, theta ,null);
    }

   
    /**
     * Constructor.
     *
     * @param pi the initial state probabilities.
     * @param a the state transition probabilities, of which a[i][j] is P(s_j |
     * s_i);
     * @param b the symbol emission probabilities, of which b[i][j] is P(o_j |
     * s_i).
     * @param symbols the list of emission symbols.
     */
    public CHMM(int[] numStatesPerChain, double[] pi, double[][] a, double[][] b, double[][] theta, O[] symbols) {
        int numChains = numStatesPerChain.length;
        int aDim = Math.sum(numStatesPerChain);

        if(numChains < 2){
            throw new IllegalArgumentException("Invalid number of chains: " + numChains);
        }
        this.numStatesPerChain = new int[numChains];

        for(int i = 0; i < numChains; i++){
            if (numStatesPerChain[i] <= 0) {
                throw new IllegalArgumentException("Invalid number of states: " + numStatesPerChain[i]+
                        " in chain "+ i+1);
            }else{
                this.numStatesPerChain[i]= numStatesPerChain[i];
            }
        }

        if (pi.length == 0 || pi.length != aDim) {
            throw new IllegalArgumentException("Invalid initial state probabilities.");
        }

        if (a.length != aDim) {
            throw new IllegalArgumentException("Invalid state transition probability matrix.");
        }
     
        if (numStatesPerChain[0] != b.length) {
            throw new IllegalArgumentException("Invalid symbol emission probability matrix.");
        }

        if (symbols != null) {
            if (b[0].length != symbols.length) {
                throw new IllegalArgumentException("Invalid size of emission symbol list.");
            }

            this.symbols = new HashMap<>();
            for (int i = 0; i < symbols.length; i++) {
                this.symbols.put(symbols[i], i);
            }
        }

        numStates = aDim;
        numSymbols = b[0].length;

        for (int i = 0; i < numStates; i++) {
            if (a[i].length != numStates) {
                throw new IllegalArgumentException("Invalid state transition probability matrix.");
            }

            double sum = 0.0;
            int numSPCIndex = 0;
            int numStatesInChain = this.numStatesPerChain[numSPCIndex];
            for (int j = 0; j < numStates; j++) {
                if (a[i][j] < 0 || a[i][j] > 1.0) {
                    throw new IllegalArgumentException("Invalid state transition probability: " + a[i][j]+
                            ". A transition from row "+ i +" to column " + j );
                }
                sum += a[i][j];
                if(j == numStatesInChain-1){
                    if (Math.abs(1.0 - sum) > 1E-7) {
                        throw new IllegalArgumentException(String.format("The row %d of state transition probability" +
                                " matrix to chain %d doesn't sum to 1.",i,(numSPCIndex + 1)));
                    }
                    numSPCIndex++;
                    numStatesInChain += (numStatesInChain < aDim)?numStatesPerChain[numSPCIndex]:0;
                    sum = 0.0;
                }
            }
        }
        for (int j = 0; j < theta[0].length; j++){
            int sum = 0;
            for (int i = 0; i < theta.length; i++){
                if (theta[i][j] < 0 || theta[i][j] > 1.0) {
                    throw new IllegalArgumentException("Invalid coupling coefficients: " + theta[i][j]+
                            ". A coupling from row "+ i +" to column " + j );
                }
                sum += theta[i][j];
            }
            if (Math.abs(1.0 - sum) > 1E-7) {
                throw new IllegalArgumentException(String.format("The coupling coefficients" +
                        " matrix to chain %d doesn't sum to 1.",j));
            }

        }

        for (int i = 0; i < this.numStatesPerChain[0]; i++) {
            if (b[i].length != numSymbols) {
                throw new IllegalArgumentException("Invalid symbol emission probability matrix.");
            }

            double sum = 0.0;

            for (int j = 0; j < numSymbols; j++) {
                if (b[i][j] < 0 || b[i][j] > 1.0) {
                    throw new IllegalArgumentException("Invalid symbol emission probability: " + b[i][j]);
                }
                sum += b[i][j];
            }

            if (Math.abs(1.0 - sum) > 1E-7) {
                throw new IllegalArgumentException(String.format("The row %d of symbol emission probability matrix doesn't sum to 1.", i));
            }
        }

        this.pi = pi;
        this.a = a;
        this.b = b;
        this.theta = theta;
    }
    
    /**
     * Generates  possible observations from 3 observation sets
     * @param a the number of observation of the first vector
     * @param b the number of observation of the second vector
     * @param c the number of observation of the third vector
     * @return all possible combinations of observations from the 3 vectors. e.g., 010, 122, etc.
     */
    public String[] multiObservationGenerator(int a, int b, int c){
        String[] obs = new String[a*b*c];
        int ind = 0;
        for(int i = 0; i < a;i++){
            for (int j = 0; j < b; j++){
                for(int k = 0; k < c; k++){
                    obs[ind] = Integer.toString(i) + j + k;
                    ind++;
                }

            }
        }
        return obs;
    }
    /**
     * Returns the number of states.
     */
    public int numStates() {
        return numStates;
    }

    /**
     * Returns the number of emission symbols.
     */
    public int numSymbols() {
        return numSymbols;
    }

    /**
     * Returns the initial state probabilities.
     */
    public double[] getInitialStateProbabilities() {
        return pi;
    }

    /**
     * Returns the state transition probabilities.
     */
    public double[][] getStateTransitionProbabilities() {
        return a;
    }

    /**
     * Returns the symbol emission probabilities.
     */
    public double[][] getSymbolEmissionProbabilities() {
        return b;
    }
    /**
     * Returns the joint probability of an observation sequence along a state
     * sequence given this HMM.
     *
     * @param o an observation sequence.
     * @param s a state sequence.
     * @return the joint probability P(o, s | H) given the model H.
     */
    public double p(int[] o, int[] s, int[] numSPC) {
        return Math.exp(logp(o, s,numSPC));
    }
   

    /**
     * Returns the log joint probability of an observation sequence along a
     * state sequence given this HMM.
     *
     * @param o an observation sequence.
     * @param s a state sequence.
     * @param nS an array containing the number of states per chain
     * @return the log joint probability P(o, s | H) given the model H.
     */
    public double logp(int[] o, int[] s, int[] nS) {
        int increment = s.length/nS.length;
        int len = o.length;
        if (len != increment) {
            throw new IllegalArgumentException("The observation sequence and the first chain state sequence are not the same length.");
        }

        double p = 0.0; //p = probability,
        int n = 0;      // n = index of the first state of each chain in an array containing all the states of all chains
        int c = 0;      // c = the number of state in each chain.
        for (int i = 0; i < nS.length; i++) {
            p += log(pi[s[0 + n] + c]);
            if (i == 0) {
                p += log(b[s[0]][o[0]]);
            }
            n += increment;
            c += nS[i];
        }

        for (int t = 1; t < len; t++) {
            int nj = 0; int cj = 0;
            for (int j = 0; j < nS.length; j++) {
                int ni = 0; int ci = 0;
                for (int i = 0; i < nS.length; i++){
                    p += log(theta[i][j]) + log(a[s[t - 1 + ni] + ci][s[t + nj] + cj]);
                    if (cj == 0 && ci == 0){
                        p += log(b[s[t]][o[t]]);
                    }
                    ni += increment;
                    ci += nS[i];
                }
                nj += increment;
                cj += nS[j];
            }
        }
        // I might need to normalize this..will check later
        return p;
    }
    
    public double logp(int[] o, int[] nSPC) {
        double[][] alpha = new double[o.length][numStates];
        double[][] scaling = new double[o.length][nSPC.length];

        forward(o, alpha, scaling, nSPC);

        double p = 1;
        int from = 0;
        int to = nSPC[0];
      //  for (int t = 0; t < o.length; t++) {
      //      p += java.lang.Math.log(Math.sum(scaling[t]);
      //  }
        for (int i = 0; i < nSPC.length; i++) {
            to += nSPC[i];
            p *= Math.sum(Arrays.copyOfRange(alpha[o.length - 1],from,to));
            from = to;
        }
        return p;
    }
    
    /**
     * Normalize alpha[t] and put the normalization factor in scaling[t][i].
     * where C is the number of chains
     * @param nSPC array of length C with nSPC[i] the length of the chain i.
     * @param scaling :scaling[t][i] contains normalization factor at time t for chain i
     * @param alpha
     * @param t the time of observation
     */
    private void scale(int[] nSPC, double[][] scaling, double[][] alpha, int t) {
        double[] table = alpha[t];

        int from = 0;
        int to = 0;
        for (int i = 0; i < nSPC.length; i++) {
            to += nSPC[i];
            scaling[t][i] = Math.sum(Arrays.copyOfRange(table,from, to));
    
            for (int j = from; j < to; j++) {
                table[j] /= scaling[t][i];
            }
            from += nSPC[i];
        }
    }
    
    
    /**
     * Scaled forward procedure without underflow.
     *
     * @param o an observation sequence.
     * @param alpha on output, alpha(i, j) holds the scaled total probability of
     * ending up in state i at time j.
     * @param scaling on output, it holds scaling factors.
     */
    private void forward(int[] o, double[][] alpha, double[][] scaling, int[] nSPC) {
        for (int k = 0; k < numStates; k++) {
            if ( k < nSPC[0]){
                alpha[0][k] = pi[k] * b[k][o[0]];
            }else{
                alpha[0][k] = pi[k];
            }

        }
        scale(nSPC, scaling, alpha, 0);

        for (int t = 1; t < o.length; t++) {
            for (int j = 0; j < numStates; j++) {
                double sum = 0.0;
                 for (int i = 0; i < numStates; i++) {
                    int[] ind = getThetaIndex(i,j,nSPC);
                    sum += theta[ind[0]][ind[1]] * a[i][j] * alpha[t - 1][i];
                }
                alpha[t][j] = (j < nSPC[0])? sum * b[j][o[t]]:sum;
            }
            scale(nSPC,scaling, alpha, t);
        }
    }

   
    /**
     * Scaled backward procedure without underflow.
     *
     * @param o an observation sequence.
     * @param beta on output, beta(i, j) holds the scaled total probability of
     * starting up in state i at time j.
     * @param scaling on input, it should hold scaling factors computed by
     * forward procedure.
     */
    private void backward(int[] o, double[][] beta, double[][] scaling, int[] nSPC) {
        int n = o.length - 1;
        int nSPCIndex = 0;
        int nS = nSPC[nSPCIndex];

        for (int i = 0; i < numStates; i++) {
            if(i == nS) {
                nSPCIndex++;
                nS += nSPC[nSPCIndex];
            }
            beta[n][i] = 1.0 / scaling[n][nSPCIndex];
        }

        for (int t = n; t-- > 0;) {
            nSPCIndex = 0;
            nS = nSPC[nSPCIndex];
            for (int i = 0; i < numStates; i++) {
                double sum = 0.0;
                for (int j = 0; j < numStates(); j++) {
                    if( j < nSPC[0]){
                        sum += beta[t + 1][j] * a[i][j] * b[j][o[t + 1]];
                    }else{
                        sum += beta[t + 1][i] * a[i][j];
                    }

                }

                if (i == nS){
                    nSPCIndex++;
                    nS += nSPC[nSPCIndex];
                }

                beta[t][i] = sum / scaling[t][nSPCIndex];
            }
        }
    }


    
    /**
     * Returns the most likely state  given the observation sequence
     * and the state sequence leading to the last observation.
     * In the calculation, we may get ties. In this
     * case, one of them is chosen randomly.
     *
     * @param o an observation sequence.
     * @param s a state sequence corresponding to the observations.
     * @return the most likely state sequence.
     */
    public int[] predict(int[] o, int[] s) {
        int C = numStatesPerChain.length;
        int inc = o.length;
        if (o.length != s.length / C) {
            throw new IllegalArgumentException("The observation sequence and state sequence are not the same length.");
        }
        // The probability of the path.
        double[][] trellis = new double[o.length][C];
        // probable next state.
        int[] nextState = new int[C];
    
        int n1 = 0;      // n = index of the first state of each chain in an array containing all the states of all chains
        int c = 0;      // c = the number of state in each chain.
    
        //forward
        for (int i = 0; i < C; i++) {
            double p = log(pi[s[0 + n1] + c]);
            if (i == 0) {
                p += log(b[s[0]][o[0]]);
            }
            trellis[0][i] = p;
            n1 += inc;
            c += numStatesPerChain[i];
        }
    
        for (int t = 1; t < o.length; t++) {
            int nj = 0;
            int cj = 0;
            for (int j = 0; j < C; j++) {
                int ni = 0;
                int ci = 0;
                double p = 0;
                for (int i = 0; i < C; i++) {
                    p += log(theta[i][j]) + trellis[t - 1][i] + log(a[s[t - 1 + ni] + ci][s[t + nj] + cj]);
                    if (cj == 0 && ci == 0) {
                        p += log(b[s[t]][o[t]]);
                    }
                    ni += inc;
                    ci += numStatesPerChain[i];
                }
                trellis[t][j] = p;
                nj += inc;
                cj += numStatesPerChain[j];
            }
        }
    
        int n = o.length - 1;
        double[] maxDelta = new double[C];
        int chainIndex = 0;
        int cj = numStatesPerChain[chainIndex];
        for (int k = 0; k < maxDelta.length; k++) {
            maxDelta[k] = Double.NEGATIVE_INFINITY;
        }
    
        for (int j = 0; j < numStates; j++) {
            double nextTrellis = 0;
            if (j == cj) {
                chainIndex++;
                cj += numStatesPerChain[chainIndex];
            }
            for (int i = 0; i < C; i++) {
                nextTrellis += log(theta[i][chainIndex]) + trellis[n][i] + log(a[s[n]][j]);
            }
            if (nextTrellis > maxDelta[chainIndex]) {
                maxDelta[chainIndex] = nextTrellis;
                nextState[chainIndex] = j;
            }
            
        }
        return nextState;
    }
    

    /**
     * Learn an HMM from labeled observation sequences by maximum likelihood
     * estimation.
     *
     * @param observations the observation sequences, of which symbols take
     * values in [0, n), where n is the number of unique symbols.
     * @param labels the state labels of observations, of which states take
     * values in [0, p), where p is the number of hidden states.
     */
    public CHMM(int[][] observations, int[][] labels, int C) {
        if (observations.length != labels.length) {
            throw new IllegalArgumentException("The number of observation sequences and that of label sequences are different.");
        }

        numSymbols = 0;
        numStatesPerChain = new int[C];
        for (int i = 0; i < observations.length; i++) {
            int n = labels[i].length/C;
            if (observations[i].length != n) {
                throw new IllegalArgumentException(String.format("The length of observation sequence %d and that of corresponding label sequence are different.", i));
            }

            int from = 0;
            int to = n;
            for (int k = 0; k  < C; k++){
                numStatesPerChain[k] = Math.max(
                        numStatesPerChain[k],1 + Math.max(Arrays.copyOfRange(labels[i], from, to))) ;
                from = to;
                to += n;
            }
            numSymbols = Math.max(numSymbols, Math.max(observations[i]) + 1);
        }

        numStates = Math.sum(numStatesPerChain);
        pi = new double[numStates];
        a = new double[numStates][numStates];
        b = new double[numStatesPerChain[0]][numSymbols];
        theta = new double[C][C];
    
        for(int i = 0; i < C; i++) {
            for (int j = 0; j < C; j++ ){
                theta[i][j] = (1.0/C);
            }
        }

        for (int m = 0; m < observations.length; m++) {
            int inc = labels[m].length/C;
            int ni = 0; int ci = 0;
            for (int i = 0; i < C; i++ ){
                pi[labels[m][i + ni] + ci ]++;
                if(i == 0){
                    b[labels[m][i]][observations[m][i]]++;
                }
                ni += inc;
                ci += numStatesPerChain[i];
            }


            for (int t = 1; t < observations[m].length; t++) {
                int nj = 0; int cj = 0;
                for (int j = 0; j < C; j++) {
                    ni = 0; ci = 0;
                    for (int i = 0; i < C; i++){
                        a[labels[m][t - 1 + ni] + ci][labels[m][t + nj] + cj]++;
                        if (cj == 0 && ci == 0){
                            b[labels[m][t]][observations[m][t]]++;
                        }
                        ni += inc;
                        ci += numStatesPerChain[i];
                    }
                    nj += inc;
                    cj += numStatesPerChain[j];
                }
            }
        }

        int from = 0;
        int to = 0;
        for (int k : numStatesPerChain){
            to += k;
            Math.unitize1(pi, from, to);
            from = to;
        }

        for (int i = 0; i < numStates; i++) {
            from = 0;
            to = 0;
            for (int j : numStatesPerChain){
                to += j;
                Math.unitize1(a[i], from, to);
                from = to;
            }
            if(i < b.length){
                Math.unitize1(b[i]);
            }
        }
    }
    
    /**
     * Learn an HMM from labeled observation sequences by maximum likelihood
     * estimation.
     *
     * @param observations the observation sequences.
     * @param labels the state labels of observations, of which states take
     * values in [0, p), where p is the number of hidden states.
     */
    public CHMM(O[][] observations, int[][] labels, int C) {
        if (observations.length != labels.length) {
            throw new IllegalArgumentException("The number of observation sequences and that of label sequences are different.");
        }

        int index = 0;
        symbols = new HashMap<>();
        for (int i = 0; i < observations.length; i++) {
            if (observations[i].length != labels[i].length/C) {
                throw new IllegalArgumentException(String.format("The length of observation sequence %d and that of corresponding label sequence are different.", i));
            }

            for (int j = 0; j < observations[i].length; j++) {
                Integer sym = symbols.get(observations[i][j]);
                if (sym == null) {
                    symbols.put(observations[i][j], index++);
                }
            }
        }

        int[][] obs = new int[observations.length][];
        for (int i = 0; i < obs.length; i++) {
            obs[i] = translate(symbols, observations[i]);
        }



        numSymbols = 0;
        numStatesPerChain = new int[C];
        for (int i = 0; i < obs.length; i++) {
            int n = labels[i].length/C;
            if (obs[i].length != n) {
                throw new IllegalArgumentException(String.format("The length of observation sequence %d and that of corresponding label sequence are different.", i));
            }

            int from = 0;
            int to = n;
            for (int k = 0; k  < C; k++){
                numStatesPerChain[k] = Math.max(
                        numStatesPerChain[k],1 + Math.max(Arrays.copyOfRange(labels[i], from, to))) ;
                from = to;
                to += n;
            }
            numSymbols = Math.max(numSymbols, Math.max(obs[i]) + 1);
        }

        numStates = Math.sum(numStatesPerChain);
        pi = new double[numStates];
        a = new double[numStates][numStates];
        b = new double[numStatesPerChain[0]][numSymbols];
        theta = new double[C][C];
        
        for(int i = 0; i < C; i++) {
            for (int j = 0; j < C; j++ ){
                theta[i][j] = (1.0/C);
            }
        }

        for (int m = 0; m < obs.length; m++) {
            int inc = labels[m].length/C;
            int ni = 0; int ci = 0;
            for (int i = 0; i < C; i++ ){
                pi[labels[m][i + ni] + ci ]++;
                if(i == 0){
                    b[labels[m][i]][obs[m][i]]++;
                }
                ni += inc;
                ci += numStatesPerChain[i];
            }


            for (int t = 1; t < obs[m].length; t++) {
                int nj = 0; int cj = 0;
                for (int j = 0; j < C; j++) {
                    ni = 0; ci = 0;
                    for (int i = 0; i < C; i++){
                        a[labels[m][t - 1 + ni] + ci][labels[m][t + nj] + cj]++;
                        if (cj == 0 && ci == 0){
                            b[labels[m][t]][obs[m][t]]++;
                        }
                        ni += inc;
                        ci += numStatesPerChain[i];
                    }
                    nj += inc;
                    cj += numStatesPerChain[j];
                }
            }
        }

        int from = 0;
        int to = 0;
        for (int k : numStatesPerChain){
            to += k;
            Math.unitize1(pi, from, to);
            from = to;
        }

        for (int i = 0; i < numStates; i++) {
            from = 0;
            to = 0;
            for (int j : numStatesPerChain){
                to += j;
                Math.unitize1(a[i], from, to);
                from = to;
            }
            if(i < b.length){
                Math.unitize1(b[i]);
            }
        }
    }
    
    /**
     * Learn an HMM from labeled observation sequences by maximum likelihood
     * estimation.
     *
     * @param observations the observation sequences.
     * @param labels the state labels of observations, of which states take
     * values in [0, p), where p is the number of hidden states.
     *  @param allPossibleObservations
     */
    public CHMM(O[][] observations, int[][] labels, int C, O[] allPossibleObservations) {
        if (observations.length != labels.length) {
            throw new IllegalArgumentException("The number of observation sequences and that of label sequences are different.");
        }

        int index = 0;
        symbols = new HashMap<>();
        for(int z = 0; z < allPossibleObservations.length;z++){
            Integer sym = symbols.get(allPossibleObservations[z]);
            if (sym == null) {
                symbols.put(allPossibleObservations[z], index++);
            }
        }
        for (int i = 0; i < observations.length; i++) {
            if (observations[i].length != labels[i].length/C) {
                throw new IllegalArgumentException(String.format("The length of observation sequence %d and that of corresponding label sequence are different.", i));
            }

            for (int j = 0; j < observations[i].length; j++) {
                Integer sym = symbols.get(observations[i][j]);
                if (sym == null) {
                    symbols.put(observations[i][j], index++);
                }
            }
        }

        int[][] obs = new int[observations.length][];
        for (int i = 0; i < obs.length; i++) {
            obs[i] = translate(symbols, observations[i]);
        }



        numSymbols = 0;
        numStatesPerChain = new int[C];
        for (int i = 0; i < obs.length; i++) {
            int n = labels[i].length/C;
            if (obs[i].length != n) {
                throw new IllegalArgumentException(String.format("The length of observation sequence %d and that of corresponding label sequence are different.", i));
            }

            int from = 0;
            int to = n;
            for (int k = 0; k  < C; k++){
                numStatesPerChain[k] = Math.max(
                        numStatesPerChain[k],1 + Math.max(Arrays.copyOfRange(labels[i], from, to))) ;
                from = to;
                to += n;
            }
            numSymbols = Math.max(numSymbols, Math.max(obs[i]) + 1);
        }

        numStates = Math.sum(numStatesPerChain);
        pi = new double[numStates];
        a = new double[numStates][numStates];
        b = new double[numStatesPerChain[0]][allPossibleObservations.length];
        theta = new double[C][C];
    
        for(int i = 0; i < C; i++) {
            for (int j = 0; j < C; j++ ){
                theta[i][j] = (1.0/C);
            }
        }

        for (int m = 0; m < obs.length; m++) {
            int inc = labels[m].length/C;
            int ni = 0; int ci = 0;
            for (int i = 0; i < C; i++ ){
                pi[labels[m][i + ni] + ci ]++;
                if(i == 0){
                    b[labels[m][i]][obs[m][i]]++;
                }
                ni += inc;
                ci += numStatesPerChain[i];
            }


            for (int t = 1; t < obs[m].length; t++) {
                int nj = 0; int cj = 0;
                for (int j = 0; j < C; j++) {
                    ni = 0; ci = 0;
                    for (int i = 0; i < C; i++){
                        a[labels[m][t - 1 + ni] + ci][labels[m][t + nj] + cj]++;
                        if (cj == 0 && ci == 0){
                            b[labels[m][t]][obs[m][t]]++;
                        }
                        ni += inc;
                        ci += numStatesPerChain[i];
                    }
                    nj += inc;
                    cj += numStatesPerChain[j];
                }
            }
        }

        int from = 0;
        int to = 0;
        for (int k : numStatesPerChain){
            to += k;
            Math.unitize1(pi, from, to);
            from = to;
        }

        for (int i = 0; i < numStates; i++) {
            from = 0;
            to = 0;
            for (int j : numStatesPerChain){
                to += j;
                Math.unitize1(a[i], from, to);
                from = to;
            }
            if(i < b.length){
                Math.unitize1(b[i]);
            }
        }
    }
    
    private int[] getThetaIndex (int i1, int j1, int[] nSPC){
        int[] ij = new int[2];
        int cSum = 0;
        for (int i = 0; i < nSPC.length; i++) {
            cSum += nSPC[i];
            if(i1 < cSum){
                ij[0] = i;
            }
            if (j1 < cSum){
                ij[1] = i;
            }
        }
        return ij;
    }
    
    private double sumZedIsJT(int[] o, double[][] alpha, int[] nSPC, int t, int j ){
        int ck = 0, nk = nSPC[ck];
        double zijt = 0.0;
        for (int k = 0; k < numStates; k++) {
            if(k == nk){
                ck++;
                nk += nSPC[ck];
            }
            if(k != j) {
                continue;
            }
            double sum = 0.0;
            int ci = 0, ni = nSPC[ci];
            for (int i = 0; i < numStates; i++) {
                if(i == ni){
                    ci++;
                    ni += nSPC[ci];
                }
                sum += theta[ci][ck] * a[i][k];
            }
            zijt = (k < nSPC[0])? sum * b[k][o[t]]:sum;
        }
        return zijt;
    }
    /**
     * Scaled forward procedure without underflow.
     *
     * @param o an observation sequence.
     * @param alpha on output, alpha(i, j) holds the scaled total probability of
     * ending up in state i at time j.
     * @param alpha
     * @param alphaChange
     * @param nSPC .
     */
    private void alphaChangeWrtPi(int[] o, double[][] alpha, double[][] alphaChange, int[] nSPC) {
        for (int k = 0; k < numStates; k++) {
                alphaChange[0][k] =   ( k < nSPC[0])? b[k][o[0]] : 1;
        }
        
        for (int t = 1; t < o.length; t++) {
            int ck = 0, nk = nSPC[ck];
            for (int k = 0; k < numStates; k++) {
                alphaChange[t][k] =  sumZedIsJT(o,alpha,nSPC,t,k) * alphaChange[t-1][k];
            }
        }
    }
    
    public void piPrimes(CHMM<O> hmm, int[] o, double[][] alpha, int[] nSPC) {
        double[][] alphaChangePi = new double[alpha.length][alpha[0].length];
        
        alphaChangeWrtPi(o, alpha, alphaChangePi, nSPC);

        double[] newPi = new double[hmm.pi.length];
        int from = 0;
        int to = 0;
        int n = o.length - 1;
        double[] piN = new double[nSPC.length];
        for (int i = 0; i < nSPC.length; i++) {
            to += nSPC[i];
            for(int j = from; j < to; j++ ){
                newPi[j] = hmm.pi[j] * alphaChangePi[n][j];
                piN[i] += newPi[j];
            }
            for(int j = from; j < to; j++ ){
                hmm.pi[j] = newPi[j]/ piN[i];
            }
            from = to;
        }
    }
    
    /**
     *
     * @param o
     * @param alpha
     * @param alphaChangeA
     * @param nSPC
     */
    private void alphaChangeWrtA(CHMM<O> hmm, int[] o, double[][] alpha, double[][][] alphaChangeA, int[] nSPC) {
    
        for (int t = 1; t < o.length; t++) {
            for (int j = 0; j < numStates; j++) {
                for (int i = 0; i < numStates; i++) {
                    int[] ind = getThetaIndex(i, j, nSPC);
                    alphaChangeA[t][i][j]  = hmm.theta[ind[0]][ind[1]] * b[j][o[t]] * alpha[t-1][i] +
                            sumZedIsJT(o,alpha,nSPC,t,j)* alphaChangeA[t - 1][i][j];
                }
            }
        
        }
    }
    
    /**
     *
     * @param o
     * @param alpha
     * @param nSPC
     */
    private void aPrimes(CHMM<O> hmm, int[] o, double[][] alpha, int[] nSPC) {
        double[][][] alphaChangeA = new double[o.length][numStates][numStates];
        alphaChangeWrtA(hmm, o, alpha, alphaChangeA, nSPC);
        int  n = alphaChangeA.length - 1;
        double[][] newA = new double[numStates][numStates];

        for ( int i = 0; i < numStates; i++){
            int from = 0;
            int to = 0;
            double[][] aN = new double[numStates][nSPC.length];
            for (int k = 0; k <nSPC.length; k++){
                to += nSPC[k];
                for (int j = from; j < to; j++ ){
                    newA[i][j] = hmm.a[i][j] * ((alphaChangeA[n][i][j] != 0)? alphaChangeA[n][i][j]: 1) ;
                    aN[i][k] += newA[i][j];
                }
                for (int j = from; j < to; j++ ){
                    hmm.a[i][j] = newA[i][j] / aN[i][k] ;
                }
                from = to;
            }
        }
    }
    
    /**
     *
     * @param o
     * @param alpha
     * @param alphaChangeB
     * @param nSPC
     */
    private void alphaChangeWrtB(CHMM<O> hmm, int[] o, double[][] alpha, double[][][] alphaChangeB, int[] nSPC) {
        for (int j = 0; j < b.length; j++) {
                for (int k = 0; k < b[0].length; k++) {
                    alphaChangeB[0][j][k] = ((o[0] == k) ? 1 : 0) * pi[j];
                }
        
            }
        
        for (int t = 1; t < o.length; t++) {
            int j = 0;
            for (j = 0; j < hmm.b.length; j++) {
                for (int k = 0; k < hmm.b[0].length; k++) {
                    double jSum = 0.0;
                    for (int i = 0; i < hmm.a.length; i++){
                        int[] ind =  getThetaIndex(i, j, nSPC);
                        jSum += ((o[t] == k) ? 1 : 0) * hmm.theta[ind[0]][ind[0]] * a[i][j] * alpha[t-1][i];
                    }
                    alphaChangeB[t][j][k] = jSum + sumZedIsJT(o,alpha,nSPC,t,j) * alphaChangeB[t - 1][j][k];
                }
                //    scale(nSPC, scaling, alphaChange, t);
            }
            
        }
    }
    
    /**
     *
     * @param o
     * @param alpha
     * @param nSPC
     */
    private void bPrimes(CHMM<O> hmm, int[] o, double[][] alpha, int[] nSPC) {
        double[][][] alphaChangeB = new double[o.length][b.length][b[0].length];
        double[][] newB = new double[hmm.b.length][hmm.b[0].length];
        alphaChangeWrtB(hmm, o, alpha, alphaChangeB, nSPC);
        int  n = alphaChangeB.length - 1;
        double[] bN = new double[hmm.b[0].length] ;
        
        for ( int j = 0; j <hmm.b.length; j++){
            for (int k = 0; k < hmm.b[0].length; k++){
                newB[j][k] = hmm.b[j][k] * alphaChangeB[n][j][k];
                bN[j] += newB[j][k];
            }
        }
    
        for ( int j = 0; j <hmm.b.length; j++){
            for (int k = 0; k < hmm.b[0].length; k++){
                hmm.b[j][k] = newB[j][k]/bN[j];
            }
        }
    }
    
    /**
     *
     * @param o
     * @param alpha
     * @param alphaChange
     * @param nSPC
     */
    private void alphaChangeWrtTheta(CHMM<O> hmm, int[] o, double[][] alpha, double[][][] alphaChange, int[] nSPC) {
        for (int j = 0; j < hmm.theta.length; j++) {
            for (int k = 0; k < hmm.theta[0].length; k++) {
                alphaChange[0][j][k] = 0.0;
            }
            
        }
        
        for (int t = 1; t < o.length; t++) {
            for (int i = 0; i < hmm.theta.length; i++) {
                for (int j = 0; j < hmm.theta[0].length; j++) {
                    alphaChange[t][i][j] = alphaChangeWrtThetaHelper1(o,alpha,nSPC,t, i, j) +
                            alphaChangeWrtThetaHelper2(hmm,o,alphaChange,nSPC,t, j);
                }
                //    scale(nSPC, scaling, alphaChange, t);
            }
            
        }
    }
    
    /**
     *
     * @param o
     * @param alpha
     * @param nSPC
     * @param t
     * @param i1
     * @param j1
     * @return
     */
    private double alphaChangeWrtThetaHelper1(int[] o, double[][] alpha, int[] nSPC, int t, int i1, int j1) {
            double thetai1j1_1 = 0.0;
            int ck = 0, nk = nSPC[ck];
            for (int k = 0; k < numStates; k++) {
                if(k == nk){
                    ck++;
                    nk += nSPC[ck];
                }
                int ci = 0, ni = nSPC[ci];
                double sum = 0.0;
                for (int i = 0; i < numStates; i++) {
                    if(i == ni){
                        ci++;
                        ni += nSPC[ci];
                    }
                    sum += (ci == i1 && ck == j1)? alpha[t - 1][i] * a[i][k]:0;
                }
                thetai1j1_1 += (k < nSPC[0])? sum * b[k][o[t]]:sum;
            }
        return thetai1j1_1;
    }
    
    /**
     *
     * @param o
     * @param alphaChange
     * @param nSPC
     * @param t
     * @param j1
     * @return
     */
    private double alphaChangeWrtThetaHelper2(CHMM<O> hmm, int[] o,double[][][] alphaChange, int[] nSPC, int t, int j1) {
        double thetai1j1_2 = 0.0;
            int ck = 0, nk = nSPC[ck];
            for (int k = 0; k < numStates; k++) {
                if(k == nk){
                    ck++;
                    nk += nSPC[ck];
                }
                double sum = 0.0;
                int ci = 0, ni = nSPC[ci];
                for (int i = 0; i < numStates; i++) {
                    if(i == ni){
                        ci++;
                        ni += nSPC[ci];
                    }
                    sum += (ck == j1)?(hmm.theta[ci][ck] * a[i][k]* alphaChange[t-1][ci][ck]):0;
                }
                thetai1j1_2 += (k < nSPC[0])? sum * b[k][o[t]]:sum;
            }
         return thetai1j1_2;
    }
    
    /**
     *
     * @param o
     * @param alpha
     * @param nSPC
     */
    private void thetaPrime(CHMM<O> hmm, int[] o, double[][] alpha, int[] nSPC) {
        double[][][] alphaChangeTheta = new double[o.length][theta.length][theta[0].length];
        double[][] newtheta = new double[theta.length][theta[0].length];
        alphaChangeWrtTheta(hmm, o, alpha, alphaChangeTheta, nSPC);
    
        int  n = alphaChangeTheta.length - 1;
        double[] thetaN = new double[theta[0].length] ;
        for ( int j = 0; j < hmm.theta[0].length; j++) {
            for (int i = 0; i < hmm.theta.length; i++) {
                newtheta[i][j] = hmm.theta[i][j] * alphaChangeTheta[n][i][j];
                thetaN[j] += newtheta[i][j];
            }
        }
    
        for ( int j = 0; j < hmm.theta[0].length; j++) {
            for (int i = 0; i < hmm.theta.length; i++) {
                hmm.theta[i][j] =  newtheta[i][j]/thetaN[j];
            }
        }
    }
    
    /**
     * With this HMM as the initial model, learn an HMM by the Lambda
     * algorithm.
     *
     * @param observations the observation sequences on which the learning is
     * based. Each sequence must have a length higher or equal to 2.
     * @param iterations the number of iterations to execute.
     * @return the updated HMM.
     */
    public CHMM<O> learn(O[][] observations, int iterations) {
        int[][] obs = new int[observations.length][];
        for (int i = 0; i < obs.length; i++) {
            obs[i] = translate(observations[i]);
        }

        return learn(obs, iterations);
    }
    
    /**
     * With this HMM as the initial model, learn an HMM by the Baum-Welch
     * algorithm / OR ....
     *
     * @param observations the observation sequences on which the learning is
     * based. Each sequence must have a length higher or equal to 2.
     * @param iterations the number of iterations to execute.
     * @return the updated HMM.
     */
    public CHMM<O> learn(int[][] observations, int iterations) {
        CHMM<O> hmm = this;

        for (int iter = 0; iter < iterations; iter++) {
            hmm = hmm.iterate(observations);
        }

        return hmm;
    }

    /** TBR
     * Performs one iteration of the Baum-Welch algorithm.
     *
     * @param sequences the training observation sequences.
     *
     * @return an updated HMM.
     */
    private CHMM<O> iterate(int[][] sequences, int C) {
        CHMM<O> hmm = new CHMM<O>(numStatesPerChain, numSymbols);
        hmm.symbols = symbols;

        // gamma[n] = gamma array associated to observation sequence n
        double gamma[][][] = new double[sequences.length][][];

        // a[i][j] = aijNum[i][j] / aijDen[i]
        // aijDen[i] = expected number of transitions from state i
        // aijNum[i][j] = expected number of transitions from state i to j
        double aijNum[][] = new double[numStates][numStates];
        double aijDen[] = new double[numStates];
        CHMM oldHmm = makeCopy(hmm);
        for (int k = 0; k < sequences.length; k++) {
            if (sequences[k].length <= 2) {
                throw new IllegalArgumentException(String.format("Training sequence %d is too short.", k));
            }

            int[] o = sequences[k];
            double[][] alpha = new double[o.length][numStates];
            double[][] beta = new double[o.length][numStates];
            double[][] scaling = new double[o.length][this.numStatesPerChain.length];
            forward(o, alpha, scaling,numStatesPerChain);
            backward(o, beta, scaling,numStatesPerChain);

            double xi[][][] = estimateXi(o, alpha, beta);
            double g[][] = gamma[k] = estimateGamma(xi);

            int n = o.length - 1;
            for (int i = 0; i < numStates; i++) {
                for (int t = 0; t < n; t++) {
                    aijDen[i] += g[t][i];

                    for (int j = 0; j < numStates; j++) {
                        aijNum[i][j] += xi[t][i][j];
                    }
                }
            }
        }

        for (int i = 0; i < numStates; i++) {
            if (aijDen[i] == 0.0) // State i is not reachable
            {
                System.arraycopy(a[i], 0, hmm.a[i], 0, numStates);
            } else {
                for (int j = 0; j < numStates; j++) {
                    hmm.a[i][j] = aijNum[i][j] / aijDen[i];
                }
            }
        }

        /*
         * initial state probability computation
         */
        for (int j = 0; j < sequences.length; j++) {
            for (int i = 0; i < numStates; i++) {
                hmm.pi[i] += gamma[j][0][i];
            }
        }

        for (int i = 0; i < numStates; i++) {
            hmm.pi[i] /= sequences.length;
        }

        /*
         * emission probability computation
         */
        for (int i = 0; i < numStates; i++) {
            double sum = 0.0;

            for (int j = 0; j < sequences.length; j++) {
                int[] o = sequences[j];
                for (int t = 0; t < o.length; t++) {
                    hmm.b[i][o[t]] += gamma[j][t][i];
                    sum += gamma[j][t][i];
                }
            }

            for (int j = 0; j < numSymbols; j++) {
                hmm.b[i][j] /= sum;
            }
        }

        printLearningCurve(oldHmm,hmm);
        return hmm;
    }


    /**
     * Performs one iteration of the Baum-Welch algorithm.
     *
     * @param sequences the training observation sequences.
     *
     * @return an updated HMM.
     */
    private CHMM<O> iterate(int[][] sequences) {
        CHMM<O> hmm = new CHMM<O>(numStatesPerChain, numSymbols);
        hmm.symbols = symbols;
        CHMM oldHmm = makeCopy(hmm);
        for (int k = 0; k < sequences.length; k++) {
            if (sequences[k].length <= 2) {
                throw new IllegalArgumentException(String.format("Traning sequence %d is too short.", k));
            }
            
            int[] o = sequences[k];
            double[][] alpha = new double[o.length][numStates];
            double[][] scaling = new double[o.length][this.numStatesPerChain.length];
            forward(o,alpha,scaling,this.numStatesPerChain);
            /*
             * initial state probability computation
             */
            piPrimes(hmm, o, alpha, numStatesPerChain);
            /*
             * transition probability computation
             */
            aPrimes(hmm, o, alpha, numStatesPerChain);
            /*
             * emission probability computation
             */
            bPrimes(hmm, o, alpha, numStatesPerChain);
            /*
             * coupling probability computation
             */
            thetaPrime(hmm, o, alpha, numStatesPerChain);
        }
       
        printLearningCurve(oldHmm,hmm);
        return hmm;
    }

    /**
     * Here, the xi (and, thus, gamma) values are not divided by the probability
     * of the sequence because this probability might be too small and induce an
     * underflow. xi[t][i][j] still can be interpreted as P(q_t = i and q_(t+1)
     * = j | O, HMM) because we assume that the scaling factors are such that
     * their product is equal to the inverse of the probability of the sequence.
     */
    private double[][][] estimateXi(int[] o, double[][] alpha, double[][] beta) {
        if (o.length <= 1) {
            throw new IllegalArgumentException("Observation sequence is too short.");
        }

        int n = o.length - 1;
        double xi[][][] = new double[n][numStates][numStates];

        for (int t = 0; t < n; t++) {
            for (int i = 0; i < numStates; i++) {
                for (int j = 0; j < numStates; j++) {
                    xi[t][i][j] = alpha[t][i] * a[i][j] * (j < 2 ? b[j][o[t + 1]]:1) * beta[t + 1][j];
                }
            }
        }

        return xi;
    }
    
    /**
     * gamma[][] could be computed directly using the alpha and beta arrays, but
     * this (slower) method is preferred because it doesn't change if the xi
     * array has been scaled (and should be changed with the scaled alpha and
     * beta arrays).
     */
    private double[][] estimateGamma(double[][][] xi) {
        double[][] gamma = new double[xi.length + 1][numStates];

        for (int t = 0; t < xi.length; t++) {
            for (int i = 0; i < numStates; i++) {
                for (int j = 0; j < numStates; j++) {
                    gamma[t][i] += xi[t][i][j];
                }
            }
        }

        int n = xi.length - 1;
        for (int j = 0; j < numStates; j++) {
            for (int i = 0; i < numStates; i++) {
                gamma[xi.length][j] += xi[n][i][j];
            }
        }

        return gamma;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("HMM (%d states, %d emission symbols)%n", numStates, numSymbols));

        sb.append("\tInitial state probability:\n\t\t");
        for (int i = 0; i < numStates; i++) {
            sb.append(String.format("%.4g ", pi[i]));
        }

        sb.append("\n\tState transition probability:");
        for (int i = 0; i < numStates; i++) {
            sb.append("\n\t\t");
            for (int j = 0; j < numStates; j++) {
                sb.append(String.format("%.4g ", a[i][j]));
            }
        }

        sb.append("\n\tSymbol emission probability:");
        for (int i = 0; i < numStates; i++) {
            sb.append("\n\t\t");
            for (int j = 0; j < numSymbols; j++) {
                sb.append(String.format("%.4g ", b[i][j]));
            }
        }

        return sb.toString();
    }
    /**
     * Returns the joint probability of an observation sequence along a state
     * sequence given this HMM.
     *
     * @param o an observation sequence.
     * @param s a state sequence.
     * @return the joint probability P(o, s | H) given the model H.
     */
    public double p(O[] o, int[] s) {
        return Math.exp(logp(o, s));
    }

    /**
     * Returns the log joint probability of an observation sequence along a
     * state sequence given this HMM.
     *
     * @param o an observation sequence.
     * @param s a state sequence.
     * @return the log joint probability P(o, s | H) given the model H.
     */
    public double logp(O[] o, int[] s) {
        return logp(translate(o), s);
    }

    /**
     * Returns the probability of an observation sequence given this HMM.
     *
     * @param o an observation sequence.
     * @return the probability of this sequence.
     */
    public double p(O[] o) {
        return Math.exp(logp(o));
    }

    /**
     * Returns the logarithm probability of an observation sequence given this
     * HMM. A scaling procedure is used in order to avoid underflows when
     * computing the probability of long sequences.
     *
     * @param o an observation sequence.
     * @return the log probability of this sequence.
     */
    public double logp(O[] o) {
        return 0.0; //logp(translate(o));
    }

    /**
     * Create a new hmm with the same parameters as the given hmm
     * @param hmm a model to copy its parameters
     * @return
     */
    private CHMM makeCopy(CHMM hmm){
        double[] npi = new double[pi.length];
        double[][] na = new double[a.length][a[0].length];
        double[][] nb = new double[b.length][b[0].length];
        double[][] ntheta = new double[numStatesPerChain.length][numStatesPerChain.length];
        for(int i = 0; i < pi.length; i++){
            npi[i] = pi[i];
            for(int j = 0; j <a[0].length; j++){
                na[i][j] = a[i][j];
            }
        }
        for (int i = 0; i < b.length; i++){
            for( int j = 0; j < b[0].length; j++){
                nb[i][j] = b[i][j];
            }
        }
        CHMM model = new CHMM(numStatesPerChain,npi,na,nb,ntheta);
        return model;
    }


    private void printLearningCurve(CHMM oldHmm,CHMM newHmm){
        double sumPi = 0.0;
        double sumA = 0.0;
        double sumB = 0.0;
        for(int i = 0; i < newHmm.pi.length; i++){
            sumPi = sumPi+ Math.abs(newHmm.pi[i] - oldHmm.pi[i]) ;
            for(int j = 0; j <newHmm.a[0].length; j++){
                sumA += Math.abs( newHmm.a[i][j] - oldHmm.a[i][j]);
            }
        }
        for (int i = 0; i < b.length; i++){
            for( int j = 0; j < newHmm.b[0].length; j++){
                sumB += Math.abs(newHmm.b[i][j] - oldHmm.b[i][j]);
            }
        }
        System.out.println("sumPi : "+sumPi+" sumA : "+sumA+" sumB : "+ sumB);


    }

//###################################################################
    /**
     * Returns natural log without underflow.
     */
    private static double log(double x) {
        double y;
        if (x < 1E-300) {
            y = -690.7755;
        } else {
            y = java.lang.Math.log(x);
        }
        return y;
    }
    
    /** TBR
     * Returns the most likely state sequence given the observation sequence by
     * the Viterbi algorithm, which maximizes the probability of
     * <code>P(I | O, HMM)</code>. In the calculation, we may get ties. In this
     * case, one of them is chosen randomly.
     *
     * @param o an observation sequence.
     * @return the most likely state sequence.
     */
    public int[] predictC(int[] o) {
        // The probability of the most probable path.
        double[][] trellis = new double[o.length][numStates];
        // Backtrace.
        int[][] psy = new int[o.length][numStates];
        // The most likely state sequence.
        int[] s = new int[o.length];
        
        // forward
        for (int i = 0; i < numStates; i++) {
            trellis[0][i] = log(pi[i]) + log(b[i][o[0]]);
            psy[0][i] = 0;
        }
        
        for (int t = 1; t < o.length; t++) {
            for (int j = 0; j < numStates; j++) {
                double maxDelta = Double.NEGATIVE_INFINITY;
                int maxPsy = 0;
                
                for (int i = 0; i < numStates; i++) {
                    double delta = trellis[t - 1][i] + log(a[i][j]);
                    
                    if (maxDelta < delta) {
                        maxDelta = delta;
                        maxPsy = i;
                    }
                }
                if(b[0].length == 33){
                    int i = 0;
                }
                //  System.out.println("t = "+t+" : j = "+j+" : o.length = "+o.length+" : b[0].length = "+ b[0].length);
                trellis[t][j] = maxDelta + log(b[j][o[t]]);
                psy[t][j] = maxPsy;
            }
        }
        
        // trace back
        int n = o.length - 1;
        double maxDelta = Double.NEGATIVE_INFINITY;
        for (int i = 0; i < numStates; i++) {
            if (maxDelta < trellis[n][i]) {
                maxDelta = trellis[n][i];
                s[n] = i;
            }
        }
        
        for (int t = n; t-- > 0;) {
            s[t] = psy[t + 1][s[t + 1]];
        }
        
        return s;
    }
    
    /**
     * Returns the most likely state sequence given the observation sequence by
     * the Viterbi algorithm, which maximizes the probability of
     * <code>P(I | O, HMM)</code>. In the calculation, we may get ties. In this
     * case, one of them is chosen randomly.
     *
     * @param o an observation sequence.
     * @return the most likely state sequence.
     */
    public int[][][] predict(int[] o) {
        int C = numStatesPerChain.length;
        // The probability of the most probable path.
        double[][] trellis = new double[o.length][numStates];
        // Backtrace.
        int[][][] psy = new int[o.length][C][numStates];
        // The most likely state sequence.
        int[][][]s = new int[o.length][C][C];

        // forward
        //int inc = o.length;
        for (int j = 0; j < numStates; j++) {
                trellis[0][j] = log(pi[j]) + ((j < numStatesPerChain[0])? log(b[j][o[0]]) : 0);
                for( int i = 0; i < C; i++) {
                    psy[0][i][j] = 0;
                }
            }
          
        //forward
        for (int t = 1; t < o.length; t++) {
            ////////////////////////////////
           // int n = o.length - 1;
            for (int j = 0; j < numStates; j++) {
                double[][] maxDelta = new double[C][C];
                int[][] maxPsy = new int[C][C];
                for (int k = 0; k < maxDelta.length; k++){
                    for(int kj = 0; kj < maxDelta.length; kj++) {
                        maxDelta[k][kj] = Double.NEGATIVE_INFINITY;
                        maxPsy[k][kj] = 0;
                    }
                }
                int i1 = 0, j1 = 0;
                for (int i = 0; i < numStates; i++) {
                    int[] tInd = getThetaIndex(i, j, numStatesPerChain);
                    i1 = tInd[0];
                    j1 = tInd[1];
                    double delta = trellis[t-1][i] + log(theta[i1][j1]) + log(a[i][j])
                            + ((i < numStatesPerChain[0])? b[j][o[t]] : 1);
                    if(delta > maxDelta[i1][j1]){
                        maxDelta[i1][j1] =  delta;
                        maxPsy[i1][j1] = i;
                    }
                }
                for ( int i = 0; i < maxDelta.length; i++) {
                    trellis[t][j] += maxDelta[i][j1];
                    psy[t][i][j] = maxPsy[i][j1];
                }
            }
        }

        // trace back
        int n = o.length - 1;
        int i1 = 0;
        int[] s1 = new int[C];
        for (int i = 0; i < C ; i++) {
            double maxDelta = Double.NEGATIVE_INFINITY;
            for (int j = 0; j < numStatesPerChain[i]; j++) {
                if (maxDelta < trellis[n][i1]) {
                    maxDelta = trellis[n][i1];
                    s[n][i][i] = i1;
                }
                i1++;
            }
        }
    
        for (int t = n; t-- > 0;) {
            for (int j = 0; j < C; j++) {
                for (int i = 0; i < C; i++) {
                    s[t][i][j] = psy[t + 1][i][s[t + 1][j][j]];
                
                }
            }
        }

        return s;
    }
    /**
     * Translate an observation sequence to internal representation.
     */
    private static <O> int[] translate(Map<O, Integer> symbols, O[] o) {
        if (symbols == null) {
            throw new IllegalArgumentException("No available emission symbol list.");
        }

        int[] seq = new int[o.length];
        for (int i = 0; i < o.length; i++) {
            Integer sym = symbols.get(o[i]);
            if (sym != null) {
                seq[i] = sym;
            } else {
                throw new IllegalArgumentException("Invalid observation symbol: " + o[i]);
            }
        }

        return seq;
    }
    /**
     * Translate an observation sequence to internal representation.
     */
    private int[] translate(O[] o) {
        return translate(symbols, o);
    }

    @Override
    public int[][][] predict(O[] o) {
        return predict(translate(o));
    }
}
